package nvdla

import chisel3._
import chisel3.experimental._
import chisel3.util._

class pdpConfiguration extends sdpConfiguration
{
    val NVDLA_PDP_BWPE = NVDLA_BPE
    val NVDLA_PDP_DMAIF_BW = NVDLA_MEMIF_WIDTH

    val SDP_THROUGHPUT = NVDLA_SDP_MAX_THROUGHPUT

    val NVDLA_PDP_ONFLY_INPUT_BW = NVDLA_PDP_BWPE*SDP_THROUGHPUT
    /////////////////////////////////////////////////////////////
    val NVDLA_PDP_MEM_MASK_NUM  = (NVDLA_PDP_DMAIF_BW/NVDLA_PDP_BWPE/NVDLA_MEMORY_ATOMIC_SIZE)
    val NVDLA_PDP_MEM_MASK_BIT = NVDLA_PDP_MEM_MASK_NUM

    val NVDLA_PDP_MEM_RD_RSP = ( NVDLA_PDP_DMAIF_BW + NVDLA_PDP_MEM_MASK_BIT )
    val NVDLA_PDP_MEM_WR_REQ = ( NVDLA_PDP_DMAIF_BW + NVDLA_PDP_MEM_MASK_BIT + 1 )
    val NVDLA_PDP_MEM_RD_REQ = ( NVDLA_MEM_ADDRESS_WIDTH + 15 )

    //redpanda3----------------
    // val DMAIF = NVDLA_CDMA_DMAIF_BW
    // val ATMC = NVDLA_MAC_ATOMIC_C_SIZE*NVDLA_BPE
    // val ATMM_NUM = DMAIF/ATMM
    // val BNUM = NVDLA_CDMA_DMAIF_BW/NVDLA_BPE
    // val MN_BW = NVDLA_CDMA_DMAIF_BW / NVDLA_BPE * 16
    // val SS = log2Ceil(ATMC/ATMM)
    // val ATMM8 = ((8*NVDLA_MEMORY_ATOMIC_SIZE)/NVDLA_MAC_ATOMIC_C_SIZE)
    // val CBUF_BANK_SIZE = NVDLA_CBUF_BANK_WIDTH * NVDLA_CBUF_BANK_DEPTH
    // val CDMA_ADDR_ALIGN = NVDLA_MEMORY_ATOMIC_SIZE
    // val CBUF_BANK_FETCH_BITS = log2Ceil(CBUF_BANK_SIZE/CDMA_ADDR_ALIGN)
    // val BANK_DEPTH_BITS = log2Ceil(ATMC/DMAIF) + log2Ceil(NVDLA_CBUF_BANK_DEPTH)

}